# Parcial 1 — Organización de Computadores

## Tema
Diseño e implementación de una **ALU de 32 bits** usando **Nand2Tetris**.  
Se propone componer la ALU32 a partir de dos **ALU de 16 bits**, promoviendo la **modularidad** y la **reutilización de componentes**, como en diseños reales de procesadores.

---

## Objetivo
Construir una **ALU32** que procese dos entradas de 32 bits (`x` e `y`), con banderas de control (`zx, nx, zy, ny, f, no`) y genere como salida:
- Resultado de 32 bits (`out`)
- Banderas de estado:
  - **zr**: salida en cero
  - **ng**: salida negativa
  - **overflow**: detección de desbordamiento aritmético

---

## Requerimientos principales

### Operaciones soportadas
- **ADD**: Suma aritmética  
- **SUB**: Resta aritmética (complemento a 2)  
- **AND**: Operación lógica bit a bit  
- **OR**: Operación lógica bit a bit  
- **NOT / NEG**: Negación lógica o aritmética  

### Banderas de estado
- **ZERO (zr):** `1` si `out == 0`  
- **NEGATIVE (ng):** `1` si el bit 31 (MSB) de `out` es `1`  
- **OVERFLOW:** Se detecta comparando el *carry-in* y el *carry-out* del bit 31  

---

## Integración de ALU16 → ALU32
- Se usan **dos ALU16**:  
  - **Parte baja:** bits `0–15`  
  - **Parte alta:** bits `16–31`  
- **Acarreo ripple:**  
  - El *carry-out* de la ALU baja alimenta el *carry-in* de la ALU alta (solo en operaciones aritméticas).  
  - En operaciones lógicas, el carry se ignora.  
- **ZERO:** calculado como la conjunción (AND) de `zr_baja` y `zr_alta`.  
- **OVERFLOW:** detectado mediante `carry_in XOR carry_out` en el bit 31.  

---

## Evaluación
Este parcial evalúa la capacidad de:
1. **Diseñar y modularizar hardware lógico**, dividiendo problemas complejos en componentes reutilizables.  
2. **Implementar una ALU32 funcional** en HDL (Hardware Description Language) usando el simulador de Nand2Tetris.  
3. **Documentar decisiones de diseño** de forma técnica y clara.  

